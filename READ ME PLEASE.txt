This code isn't great.
Some things are hacky, which is to be expected when the scale of the game is meant to be small. A good example of this is how character unique properties are done- very fundamental methods like move_player or attack() have hardcoded exceptions in them based on what character you're using. This isn't an extendable system, but it's not meant to be- the scale of the game was meant to be small.
Some decisions are either less convenient for me or just bad, and they couldn't be fixed without a rewrite of a lot of parts of the game that wouldn't be justifiable for how little gain they would provide in the long run. I hope this project is educational to people not through the correct things I did, but through the mistakes I made as well.

The biggest problem with the project is the fact that ground tiles are rendered through individual Sprite2D nodes and not a Tilemap. This means that each tile costs more memory and performance, and the difference between a tilemap and a bunch of nodes *compounds* the larger the levels become. There's a significant increase in loading time because of memory costs when you get to 16x16 levels, and the game sags a little bit on 32x32 levels.
This decision at the time made sense, and it honestly doesn't affect the game that much, because the game was meant to have small levels and even smaller challenge set pieces. Another thing I expected is mutability of ground tiles- that they would change properties at some point, and that having nodes would make changing ground tiles easier. This is sort of correct, as thrown weapons do change their "hp" value after every toss, but there's ways around this in a Tilemap implementation.
Tilemaps in Godot 4 have tile layers. This means that I don't have to bake hp/attack values for tile cards, and instead have a separate layer for the hp value and the attack value drawn over the tile graphics. Even in Godot 3, you could get over this with additional Tilemap nodes.
Unfortunately, by the time I realized node tiles were a much larger problem than I originally predicted, I had already coded the level editor, which used code in card nodes to draw stuff. Rewriting the system would set me back 3-5 days of work to reduce loading times for levels that weren't meant to be in the game in the first place. 

The units in this game are stored in a grid that mirrors the 'field' ground tile grid. It is likely more efficient to use a unit list with position vars instead of having the units var be a 2d array. Less memory consumption, only flaw is having to loop through units and check positionXY each time you try to do something in regard to specific positions, which is offset by the now much lower amount of entries. This would also solve the problem of having to check unit != null each time you want to do anything. Overall this would be a mildly faster approach, as a grid for units should only really be used if units are expected to have a similar count to tiles(like 30-50%). This would never happen in, probably, any kind of game, let alone a dungeon crawler.

When you place in a tile or unit, it loads the dictionary for that card into the file fully. What this means, besides large file sizes(not very relevant), is that whenever a tile type gets edits or additions, the version of the tile on disk IS NOT updated. This is pretty bad for constantly updated projects, but as this game is already pretty simple, it's reasonable for me to expect all card data to be finished before any of the level design even starts. Don't do this for larger projects. 
To solve this issue, you can have two approaches, one of which is "fast" and another is "correct".
The correct approach is having a file editing/loading/saving system separate from the gameplay. This separate editor wouldn't save game state at all like the current file system , and it would instead save tileid and unitid strings into arrays along with expected grid costraints. When loading, these strings would correspond to dictionaries through an id dictionary, with strings as the key and references to Dictionary consts. This would take more time to develop, and adding more card types would become slightly annoying as you would need to add a Dictionary AND an id entry each time, however, it can be easily *added* to a game state edit system instead of replacing it entirely- game states are still useful for saving, and having an editor for that is still a great tool for debugging and cheating.
Another "correct" approach would be not having Dictionaries loaded into memory or disk at any point, and saving ONLY ids to the grid, then using an id table similar to the above for checking how different tiles can be. This would require a massive rewrite, however, and would also make tiles immutable. I have intentionally made the code more adaptable over performance to allow for mid-game changes to all card types in case we decide to change the direction of the game. Mutability of ground tiles ended up being useful with the Campfire adding more spawned enemies on each use. 
The "fast" approach would be adding a "tileid" var to each tile. Yes, this is confusing because the variable I SHOULD have named "visual" or "texture" is named tileid. This id var would be hooked up to a dictionary similar to the one I use for custom random cards during level generation, with a key being an id string and its definition being the tile Dictionary. Any time a tile is loaded from disk into the game, the game wouldn't save the actual Dictionary values into the game, but the default values. It would be a lot like the first approach, but somewhat more hacky and wasteful. The same level format could still be used for savestates though, which is an advantage.
